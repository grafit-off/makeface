{"version":3,"sources":["main.js"],"names":["popupLinks","document","querySelectorAll","lockPadding","body","querySelector","unlock","timeout","length","index","popupLink","addEventListener","e","popupName","getAttribute","replace","popupOpen","getElementById","preventDefault","popupCloseIcon","el","popupClose","closest","curentPopup","popupActive","bodyLock","classList","add","target","doUnlock","remove","bodyUnlock","lockPaddingValue","window","innerWidth","offsetWidth","style","paddingRight","setTimeout","which","Element","prototype","css","node","this","matches","parentElement","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","slice","Array","_focusableElementsString","join","InertRoot","[object Object]","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","managedNodes","hasSavedAriaHidden","savedAriaHidden","ariaHidden","startNode","composedTreeWalk","_visitNode","activeElement","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","deregister","delete","inertSubroot","getInertRoot","setInert","savedInertNode","records","self","record","type","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","hasSavedTabIndex","savedTabIndex","tabIndex","size","destructor","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","_onDocumentLoaded","inert","has","set","parent","get","addInertRoot","removeInertRoot","inertElement","_this","inertElements","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","i","slot","assignedNodes","flatten","child","firstChild","nextSibling","createElement","textContent","appendChild","hasOwnProperty","Object","defineProperty","enumerable","wrapper","headerBurger","headerMenu","md2","matchMedia","toggle","from","children","isiPhone","navigator","userAgent","match","isiPad","isiPod","linkNav","V","w","pageYOffset","hash","href","t","getBoundingClientRect","top","start","requestAnimationFrame","step","time","progress","r","Math","max","min","scrollTo","location","header","prevScrollpos","navOpen","navScroll","onscroll","currentScrollPos"],"mappings":"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","file":"main.js","sourcesContent":["const popupLinks = document.querySelectorAll('.popup-link');\r\nconst lockPadding = document.querySelectorAll('.lock-padding');\r\nconst body = document.querySelector('body')\r\nlet unlock = true;\r\n\r\nconst timeout = 800;\r\n\r\nif (popupLinks.length > 0) {\r\n\tfor (let index = 0; index < popupLinks.length; index++) {\r\n\t\tconst popupLink = popupLinks[index];\r\n\t\tpopupLink.addEventListener(\"click\", function (e) {\r\n\t\t\tconst popupName = popupLink.getAttribute('href').replace('#', '');\r\n\t\t\tconst curentPopup = document.getElementById(popupName);\r\n\t\t\tpopupOpen(curentPopup);\r\n\t\t\te.preventDefault();\r\n\t\t});\r\n\t}\r\n}\r\n\r\nconst popupCloseIcon = document.querySelectorAll('.close-popup');\r\nif (popupCloseIcon.length > 0) {\r\n\tfor (let index = 0; index < popupCloseIcon.length; index++) {\r\n\t\tconst el = popupCloseIcon[index];\r\n\t\tel.addEventListener('click', function (e) {\r\n\t\t\tpopupClose(el.closest('.popup'));\r\n\t\t\te.preventDefault();\r\n\t\t});\r\n\t}\r\n}\r\n\r\nfunction popupOpen(curentPopup) {\r\n\tif (curentPopup && unlock) {\r\n\t\tconst popupActive = document.querySelector('.popup.open');\r\n\t\tif (popupActive) {\r\n\t\t\tpopupClose(popupActive, false);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbodyLock();\r\n\t\t}\r\n\t\tcurentPopup.classList.add('open');\r\n\t\tcurentPopup.addEventListener(\"click\", function (e) {\r\n\t\t\tif (!e.target.closest('.popup__content')) {\r\n\t\t\t\tpopupClose(e.target.closest('.popup'));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\nfunction popupClose(popupActive, doUnlock = true) {\r\n\tif (unlock) {\r\n\t\tpopupActive.classList.remove('open');\r\n\t\tif (doUnlock) {\r\n\t\t\tbodyUnlock();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction bodyLock() {\r\n\tconst lockPaddingValue = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';\r\n\r\n\tif (lockPadding.length > 0) {\r\n\t\tfor (let index = 0; index < lockPadding.length; index++) {\r\n\t\t\tconst el = lockPadding[index];\r\n\t\t\tel.style.paddingRight = lockPaddingValue;\r\n\t\t}\r\n\t}\r\n\r\n\tbody.style.paddingRight = lockPaddingValue;\r\n\tbody.classList.add('lock');\r\n\r\n\tunlock = false;\r\n\tsetTimeout(function () {\r\n\t\tunlock = true;\r\n\t}, timeout);\r\n}\r\nfunction bodyUnlock() {\r\n\tsetTimeout(function () {\r\n\t\tif (lockPadding.length > 0) {\r\n\t\t\tfor (let index = 0; index < lockPadding.length; index++) {\r\n\t\t\t\tconst el = lockPadding[index];\r\n\t\t\t\tel.style.paddingRight = '0px';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbody.style.paddingRight = '0px';\r\n\t\tbody.classList.remove('lock');\r\n\t}, timeout);\r\n}\r\n\r\ndocument.addEventListener('keydown', function (e) {\r\n\tif (e.which === 27) {\r\n\t\tconst popupActive = document.querySelector('.popup.open');\r\n\t\tpopupClose(popupActive);\r\n\t}\r\n});\r\n(function () {\r\n\tif (!Element.prototype.closest) {\r\n\t\tElement.prototype.closest = function (css) {\r\n\t\t\tvar node = this;\r\n\t\t\twhile (node) {\r\n\t\t\t\tif (node.matches(css)) return node;\r\n\t\t\t\telse node = node.parentElement;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t}\r\n})();\r\n(function () {\r\n\tif (!Element.prototype.matches) {\r\n\t\tElement.prototype.matches = Element.prototype.matchesSelector ||\r\n\t\t\tElement.prototype.webkitMatchesSelector ||\r\n\t\t\tElement.prototype.mozMatchesSelector ||\r\n\t\t\tElement.prototype.msMatchesSelector;\r\n\t}\r\n})();;\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n// Convenience function for converting NodeLists.\n/** @type {typeof Array.prototype.slice} */\nconst slice = Array.prototype.slice;\n\n/**\n * IE has a non-standard name for \"matches\".\n * @type {typeof Element.prototype.matches}\n */\nconst matches =\n    Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n/** @type {string} */\nconst _focusableElementsString = ['a[href]',\n                                  'area[href]',\n                                  'input:not([disabled])',\n                                  'select:not([disabled])',\n                                  'textarea:not([disabled])',\n                                  'button:not([disabled])',\n                                  'details',\n                                  'summary',\n                                  'iframe',\n                                  'object',\n                                  'embed',\n                                  '[contenteditable]'].join(',');\n\n/**\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n * attribute.\n *\n * Its main functions are:\n *\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\n *\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\n *   `deregister` method on `InertManager` for each managed inert node.\n */\nclass InertRoot {\n  /**\n   * @param {!Element} rootElement The Element at the root of the inert subtree.\n   * @param {!InertManager} inertManager The global singleton InertManager object.\n   */\n  constructor(rootElement, inertManager) {\n    /** @type {!InertManager} */\n    this._inertManager = inertManager;\n\n    /** @type {!Element} */\n    this._rootElement = rootElement;\n\n    /**\n     * @type {!Set<!InertNode>}\n     * All managed focusable nodes in this InertRoot's subtree.\n     */\n    this._managedNodes = new Set();\n\n    // Make the subtree hidden from assistive technology\n    if (this._rootElement.hasAttribute('aria-hidden')) {\n      /** @type {?string} */\n      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n    } else {\n      this._savedAriaHidden = null;\n    }\n    this._rootElement.setAttribute('aria-hidden', 'true');\n\n    // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n    this._makeSubtreeUnfocusable(this._rootElement);\n\n    // Watch for:\n    // - any additions in the subtree: make them unfocusable too\n    // - any removals from the subtree: remove them from this inert root's managed nodes\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n    //   element, make that node a managed node.\n    this._observer = new MutationObserver(this._onMutation.bind(this));\n    this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n   * stored in this object and updates the state of all of the managed nodes.\n   */\n  destructor() {\n    this._observer.disconnect();\n\n    if (this._rootElement) {\n      if (this._savedAriaHidden !== null) {\n        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n      } else {\n        this._rootElement.removeAttribute('aria-hidden');\n      }\n    }\n\n    this._managedNodes.forEach(function(inertNode) {\n      this._unmanageNode(inertNode.node);\n    }, this);\n\n    // Note we cast the nulls to the ANY type here because:\n    // 1) We want the class properties to be declared as non-null, or else we\n    //    need even more casts throughout this code. All bets are off if an\n    //    instance has been destroyed and a method is called.\n    // 2) We don't want to cast \"this\", because we want type-aware optimizations\n    //    to know which properties we're setting.\n    this._observer = /** @type {?} */ (null);\n    this._rootElement = /** @type {?} */ (null);\n    this._managedNodes = /** @type {?} */ (null);\n    this._inertManager = /** @type {?} */ (null);\n  }\n\n  /**\n   * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n   */\n  get managedNodes() {\n    return new Set(this._managedNodes);\n  }\n\n  /** @return {boolean} */\n  get hasSavedAriaHidden() {\n    return this._savedAriaHidden !== null;\n  }\n\n  /** @param {?string} ariaHidden */\n  set savedAriaHidden(ariaHidden) {\n    this._savedAriaHidden = ariaHidden;\n  }\n\n  /** @return {?string} */\n  get savedAriaHidden() {\n    return this._savedAriaHidden;\n  }\n\n  /**\n   * @param {!Node} startNode\n   */\n  _makeSubtreeUnfocusable(startNode) {\n    composedTreeWalk(startNode, (node) => this._visitNode(node));\n\n    let activeElement = document.activeElement;\n\n    if (!document.body.contains(startNode)) {\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n      let node = startNode;\n      /** @type {!ShadowRoot|undefined} */\n      let root = undefined;\n      while (node) {\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          root = /** @type {!ShadowRoot} */ (node);\n          break;\n        }\n        node = node.parentNode;\n      }\n      if (root) {\n        activeElement = root.activeElement;\n      }\n    }\n    if (startNode.contains(activeElement)) {\n      activeElement.blur();\n      // In IE11, if an element is already focused, and then set to tabindex=-1\n      // calling blur() will not actually move the focus.\n      // To work around this we call focus() on the body instead.\n      if (activeElement === document.activeElement) {\n        document.body.focus();\n      }\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   */\n  _visitNode(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (node);\n\n    // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n    if (element !== this._rootElement && element.hasAttribute('inert')) {\n      this._adoptInertRoot(element);\n    }\n\n    if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n      this._manageNode(element);\n    }\n  }\n\n  /**\n   * Register the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _manageNode(node) {\n    const inertNode = this._inertManager.register(node, this);\n    this._managedNodes.add(inertNode);\n  }\n\n  /**\n   * Unregister the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _unmanageNode(node) {\n    const inertNode = this._inertManager.deregister(node, this);\n    if (inertNode) {\n      this._managedNodes.delete(inertNode);\n    }\n  }\n\n  /**\n   * Unregister the entire subtree starting at `startNode`.\n   * @param {!Node} startNode\n   */\n  _unmanageSubtree(startNode) {\n    composedTreeWalk(startNode, (node) => this._unmanageNode(node));\n  }\n\n  /**\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n   * @param {!Element} node\n   */\n  _adoptInertRoot(node) {\n    let inertSubroot = this._inertManager.getInertRoot(node);\n\n    // During initialisation this inert root may not have been registered yet,\n    // so register it now if need be.\n    if (!inertSubroot) {\n      this._inertManager.setInert(node, true);\n      inertSubroot = this._inertManager.getInertRoot(node);\n    }\n\n    inertSubroot.managedNodes.forEach(function(savedInertNode) {\n      this._manageNode(savedInertNode.node);\n    }, this);\n  }\n\n  /**\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _onMutation(records, self) {\n    records.forEach(function(record) {\n      const target = /** @type {!Element} */ (record.target);\n      if (record.type === 'childList') {\n        // Manage added nodes\n        slice.call(record.addedNodes).forEach(function(node) {\n          this._makeSubtreeUnfocusable(node);\n        }, this);\n\n        // Un-manage removed nodes\n        slice.call(record.removedNodes).forEach(function(node) {\n          this._unmanageSubtree(node);\n        }, this);\n      } else if (record.type === 'attributes') {\n        if (record.attributeName === 'tabindex') {\n          // Re-initialise inert node if tabindex changes\n          this._manageNode(target);\n        } else if (target !== this._rootElement &&\n                   record.attributeName === 'inert' &&\n                   target.hasAttribute('inert')) {\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n          // already managed nodes from this inert subroot.\n          this._adoptInertRoot(target);\n          const inertSubroot = this._inertManager.getInertRoot(target);\n          this._managedNodes.forEach(function(managedNode) {\n            if (target.contains(managedNode.node)) {\n              inertSubroot._manageNode(managedNode.node);\n            }\n          });\n        }\n      }\n    }, this);\n  }\n}\n\n/**\n * `InertNode` initialises and manages a single inert node.\n * A node is inert if it is a descendant of one or more inert root elements.\n *\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n * is intrinsically focusable or not.\n *\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\n */\nclass InertNode {\n  /**\n   * @param {!Node} node A focusable element to be made inert.\n   * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n   */\n  constructor(node, inertRoot) {\n    /** @type {!Node} */\n    this._node = node;\n\n    /** @type {boolean} */\n    this._overrodeFocusMethod = false;\n\n    /**\n     * @type {!Set<!InertRoot>} The set of descendant inert roots.\n     *    If and only if this set becomes empty, this node is no longer inert.\n     */\n    this._inertRoots = new Set([inertRoot]);\n\n    /** @type {?number} */\n    this._savedTabIndex = null;\n\n    /** @type {boolean} */\n    this._destroyed = false;\n\n    // Save any prior tabindex info and make this node untabbable\n    this.ensureUntabbable();\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.\n   * This makes the managed node focusable again and deletes all of the previously stored state.\n   */\n  destructor() {\n    this._throwIfDestroyed();\n\n    if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n      const element = /** @type {!Element} */ (this._node);\n      if (this._savedTabIndex !== null) {\n        element.setAttribute('tabindex', this._savedTabIndex);\n      } else {\n        element.removeAttribute('tabindex');\n      }\n\n      // Use `delete` to restore native focus method.\n      if (this._overrodeFocusMethod) {\n        delete element.focus;\n      }\n    }\n\n    // See note in InertRoot.destructor for why we cast these nulls to ANY.\n    this._node = /** @type {?} */ (null);\n    this._inertRoots = /** @type {?} */ (null);\n    this._destroyed = true;\n  }\n\n  /**\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n   * If the object has been destroyed, any attempt to access it will cause an exception.\n   */\n  get destroyed() {\n    return /** @type {!InertNode} */ (this)._destroyed;\n  }\n\n  /**\n   * Throw if user tries to access destroyed InertNode.\n   */\n  _throwIfDestroyed() {\n    if (this.destroyed) {\n      throw new Error('Trying to access destroyed InertNode');\n    }\n  }\n\n  /** @return {boolean} */\n  get hasSavedTabIndex() {\n    return this._savedTabIndex !== null;\n  }\n\n  /** @return {!Node} */\n  get node() {\n    this._throwIfDestroyed();\n    return this._node;\n  }\n\n  /** @param {?number} tabIndex */\n  set savedTabIndex(tabIndex) {\n    this._throwIfDestroyed();\n    this._savedTabIndex = tabIndex;\n  }\n\n  /** @return {?number} */\n  get savedTabIndex() {\n    this._throwIfDestroyed();\n    return this._savedTabIndex;\n  }\n\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\n  ensureUntabbable() {\n    if (this.node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (this.node);\n    if (matches.call(element, _focusableElementsString)) {\n      if (/** @type {!HTMLElement} */ (element).tabIndex === -1 &&\n          this.hasSavedTabIndex) {\n        return;\n      }\n\n      if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      }\n      element.setAttribute('tabindex', '-1');\n      if (element.nodeType === Node.ELEMENT_NODE) {\n        element.focus = function() {};\n        this._overrodeFocusMethod = true;\n      }\n    } else if (element.hasAttribute('tabindex')) {\n      this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      element.removeAttribute('tabindex');\n    }\n  }\n\n  /**\n   * Add another inert root to this inert node's set of managing inert roots.\n   * @param {!InertRoot} inertRoot\n   */\n  addInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.add(inertRoot);\n  }\n\n  /**\n   * Remove the given inert root from this inert node's set of managing inert roots.\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\n   * so the object should be destroyed.\n   * @param {!InertRoot} inertRoot\n   */\n  removeInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.delete(inertRoot);\n    if (this._inertRoots.size === 0) {\n      this.destructor();\n    }\n  }\n}\n\n/**\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\n *\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n * is created for each such node, via the `_managedNodes` map.\n */\nclass InertManager {\n  /**\n   * @param {!Document} document\n   */\n  constructor(document) {\n    if (!document) {\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\n    }\n\n    /** @type {!Document} */\n    this._document = document;\n\n    /**\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertNode>}\n     */\n    this._managedNodes = new Map();\n\n    /**\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertRoot>}\n     */\n    this._inertRoots = new Map();\n\n    /**\n     * Observer for mutations on `document.body`.\n     * @type {!MutationObserver}\n     */\n    this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n    // Add inert style.\n    addInertStyle(document.head || document.body || document.documentElement);\n\n    // Wait for document to be loaded.\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n    } else {\n      this._onDocumentLoaded();\n    }\n  }\n\n  /**\n   * Set whether the given element should be an inert root or not.\n   * @param {!Element} root\n   * @param {boolean} inert\n   */\n  setInert(root, inert) {\n    if (inert) {\n      if (this._inertRoots.has(root)) { // element is already inert\n        return;\n      }\n\n      const inertRoot = new InertRoot(root, this);\n      root.setAttribute('inert', '');\n      this._inertRoots.set(root, inertRoot);\n      // If not contained in the document, it must be in a shadowRoot.\n      // Ensure inert styles are added there.\n      if (!this._document.body.contains(root)) {\n        let parent = root.parentNode;\n        while (parent) {\n          if (parent.nodeType === 11) {\n            addInertStyle(parent);\n          }\n          parent = parent.parentNode;\n        }\n      }\n    } else {\n      if (!this._inertRoots.has(root)) { // element is already non-inert\n        return;\n      }\n\n      const inertRoot = this._inertRoots.get(root);\n      inertRoot.destructor();\n      this._inertRoots.delete(root);\n      root.removeAttribute('inert');\n    }\n  }\n\n  /**\n   * Get the InertRoot object corresponding to the given inert root element, if any.\n   * @param {!Node} element\n   * @return {!InertRoot|undefined}\n   */\n  getInertRoot(element) {\n    return this._inertRoots.get(element);\n  }\n\n  /**\n   * Register the given InertRoot as managing the given node.\n   * In the case where the node has a previously existing inert root, this inert root will\n   * be added to its set of inert roots.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {!InertNode} inertNode\n   */\n  register(node, inertRoot) {\n    let inertNode = this._managedNodes.get(node);\n    if (inertNode !== undefined) { // node was already in an inert subtree\n      inertNode.addInertRoot(inertRoot);\n    } else {\n      inertNode = new InertNode(node, inertRoot);\n    }\n\n    this._managedNodes.set(node, inertNode);\n\n    return inertNode;\n  }\n\n  /**\n   * De-register the given InertRoot as managing the given inert node.\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n   * node from the InertManager's set of managed nodes if it is destroyed.\n   * If the node is not currently managed, this is essentially a no-op.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n   */\n  deregister(node, inertRoot) {\n    const inertNode = this._managedNodes.get(node);\n    if (!inertNode) {\n      return null;\n    }\n\n    inertNode.removeInertRoot(inertRoot);\n    if (inertNode.destroyed) {\n      this._managedNodes.delete(node);\n    }\n\n    return inertNode;\n  }\n\n  /**\n   * Callback used when document has finished loading.\n   */\n  _onDocumentLoaded() {\n    // Find all inert roots in document and make them actually inert.\n    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n    inertElements.forEach(function(inertElement) {\n      this.setInert(inertElement, true);\n    }, this);\n\n    // Comment this out to use programmatic API only.\n    this._observer.observe(this._document.body || this._document.documentElement, {attributes: true, subtree: true, childList: true});\n  }\n\n  /**\n   * Callback used when mutation observer detects attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _watchForInert(records, self) {\n    const _this = this;\n    records.forEach(function(record) {\n      switch (record.type) {\n      case 'childList':\n        slice.call(record.addedNodes).forEach(function(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          const inertElements = slice.call(node.querySelectorAll('[inert]'));\n          if (matches.call(node, '[inert]')) {\n            inertElements.unshift(node);\n          }\n          inertElements.forEach(function(inertElement) {\n            this.setInert(inertElement, true);\n          }, _this);\n        }, _this);\n        break;\n      case 'attributes':\n        if (record.attributeName !== 'inert') {\n          return;\n        }\n        const target = /** @type {!Element} */ (record.target);\n        const inert = target.hasAttribute('inert');\n        _this.setInert(target, inert);\n        break;\n      }\n    }, this);\n  }\n}\n\n/**\n * Recursively walk the composed tree from |node|.\n * @param {!Node} node\n * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n *     before descending into child nodes.\n * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n */\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\n  if (node.nodeType == Node.ELEMENT_NODE) {\n    const element = /** @type {!Element} */ (node);\n    if (callback) {\n      callback(element);\n    }\n\n    // Descend into node:\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\n    // up by the <content> or <shadow> elements. Descend straight into the\n    // ShadowRoot.\n    const shadowRoot = /** @type {!HTMLElement} */ (element).shadowRoot;\n    if (shadowRoot) {\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\n      return;\n    }\n\n    // If it is a <content> element, descend into distributed elements - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'content') {\n      const content = /** @type {!HTMLContentElement} */ (element);\n      // Verifies if ShadowDom v0 is supported.\n      const distributedNodes = content.getDistributedNodes ?\n        content.getDistributedNodes() : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n\n    // If it is a <slot> element, descend into assigned nodes - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'slot') {\n      const slot = /** @type {!HTMLSlotElement} */ (element);\n      // Verify if ShadowDom v1 is supported.\n      const distributedNodes = slot.assignedNodes ?\n        slot.assignedNodes({flatten: true}) : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n  }\n\n  // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n  // element, nor a <shadow> element recurse normally.\n  let child = node.firstChild;\n  while (child != null) {\n    composedTreeWalk(child, callback, shadowRootAncestor);\n    child = child.nextSibling;\n  }\n}\n\n/**\n * Adds a style element to the node containing the inert specific styles\n * @param {!Node} node\n */\nfunction addInertStyle(node) {\n  if (node.querySelector('style#inert-style')) {\n    return;\n  }\n  const style = document.createElement('style');\n  style.setAttribute('id', 'inert-style');\n  style.textContent = '\\n'+\n                      '[inert] {\\n' +\n                      '  pointer-events: none;\\n' +\n                      '  cursor: default;\\n' +\n                      '}\\n' +\n                      '\\n' +\n                      '[inert], [inert] * {\\n' +\n                      '  user-select: none;\\n' +\n                      '  -webkit-user-select: none;\\n' +\n                      '  -moz-user-select: none;\\n' +\n                      '  -ms-user-select: none;\\n' +\n                      '}\\n';\n  node.appendChild(style);\n}\n\n/** @type {!InertManager} */\nconst inertManager = new InertManager(document);\n\nif (!Element.prototype.hasOwnProperty('inert')) {\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    /** @this {!Element} */\n    get: function() {\n      return this.hasAttribute('inert');\n    },\n    /** @this {!Element} */\n    set: function(inert) {\n      inertManager.setInert(this, inert);\n    },\n  });\n}\n;\n\n// Burger Menu\nconst wrapper = document.querySelector('.wrapper')\nconst headerBurger = document.querySelector('.header__burger');\nconst headerMenu = document.querySelector('.header__menu');\nconst md2 = window.matchMedia(\"(max-width: 767px)\")\nif (md2.matches) {\n\theaderMenu.inert = true;\n\theaderBurger.addEventListener('click', () => {\n\t\theaderBurger.classList.toggle('active');\n\t\theaderMenu.classList.toggle('active');\n\t\tbody.classList.toggle('lock');\n\t\theaderMenu.inert = false;\n\t\tArray.from(wrapper.children).forEach((child) => {\n\t\t\tif (child !== document.querySelector('.header')) {\n\t\t\t\tchild.inert = true;\n\t\t\t}\n\t\t});\n\t\tif (!headerMenu.classList.contains('active')) {\n\t\t\theaderMenu.inert = true;\n\t\t\tArray.from(wrapper.children).forEach((child) => {\n\t\t\t\tif (child !== document.querySelector('.header')) {\n\t\t\t\t\tchild.inert = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})\n}\n// -- //\n\n// Scroll to link\nconst isiPhone = (navigator.userAgent.match(/iPhone/i) != null);\nconst isiPad = (navigator.userAgent.match(/iPad/i) != null);\nconst isiPod = (navigator.userAgent.match(/iPod/i) != null);\n\nif (isiPhone || isiPad || isiPod) {\n\tlet linkNav = document.querySelectorAll('[href^=\"#\"]'), //выбираем все ссылки к якорю на странице\n\t\tV = 0.2;  // скорость, может иметь дробное значение через точку (чем меньше значение - тем больше скорость)\n\tfor (let i = 0; i < linkNav.length; i++) {\n\t\tlinkNav[i].addEventListener('click', function (e) { //по клику на ссылку\n\t\t\te.preventDefault(); //отменяем стандартное поведение\n\t\t\tlet w = window.pageYOffset,  // производим прокрутка прокрутка\n\t\t\t\thash = this.href.replace(/[^#]*(.*)/, '$1');  // к id элемента, к которому нужно перейти\n\t\t\tt = document.querySelector(hash).getBoundingClientRect().top,  // отступ от окна браузера до id\n\t\t\t\tstart = null;\n\t\t\trequestAnimationFrame(step);  // подробнее про функцию анимации [developer.mozilla.org]\n\t\t\tfunction step(time) {\n\t\t\t\tif (start === null) start = time;\n\t\t\t\tlet progress = time - start,\n\t\t\t\t\tr = (t < 0 ? Math.max(w - progress / V, w + t) : Math.min(w + progress / V, w + t));\n\t\t\t\twindow.scrollTo(0, r);\n\t\t\t\tif (r != w + t) {\n\t\t\t\t\trequestAnimationFrame(step)\n\t\t\t\t} else {\n\t\t\t\t\tlocation.hash = hash  // URL с хэшем\n\t\t\t\t}\n\t\t\t}\n\t\t}, false);\n\t}\n}\n// -- //\n\n\n// Active header on scroll\nconst header = document.querySelector(\".header\");\nlet prevScrollpos = window.pageYOffset;\n\nfunction navOpen() {\n\tif (prevScrollpos != 0) {\n\t\theader.classList.add('header--active');\n\n\t} else {\n\t\theader.classList.remove('header--active');\n\t}\n}\nfunction navScroll() {\n\twindow.onscroll = function () {\n\t\tlet currentScrollPos = window.pageYOffset;\n\t\tif (prevScrollpos < currentScrollPos) {\n\t\t\theader.classList.add('header--active');\n\t\t} else if (prevScrollpos = currentScrollPos) {\n\t\t\theader.classList.add('header--active');\n\t\t} else {\n\t\t\theader.classList.remove('header--active');\n\t\t}\n\t\tprevScrollpos = currentScrollPos;\n\t}\n}\nnavOpen()\nnavScroll()\n// -- //"]}